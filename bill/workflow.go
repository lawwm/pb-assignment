package bill

import (
	"time"

	"go.temporal.io/sdk/temporal"
	"go.temporal.io/sdk/workflow"
)

const (
	signalAddLineItem = "add-line-item"
	signalCloseBill   = "close-bill"
)

// Start params must include BillID (generated by handler).
type BillWorkflowParams struct {
	BillID   string
	Currency Currency
}

// Signals also include LineItemID for idempotency.
type AddLineItemSignal struct {
	LineItemID  string
	Description string
	AmountMinor int64
	Currency    Currency
}

type CloseBillSignal struct{}

type BillResult struct {
	BillID      string
	Currency    Currency
	TotalMinor  int64
	LineItemIDs []string
}

func BillLifecycleWorkflow(ctx workflow.Context, params BillWorkflowParams) (*BillResult, error) {
	ao := workflow.ActivityOptions{
		StartToCloseTimeout: 10 * time.Second,
		RetryPolicy: &temporal.RetryPolicy{
			InitialInterval:    200 * time.Millisecond,
			BackoffCoefficient: 2.0,
			MaximumInterval:    2 * time.Second,
			MaximumAttempts:    5,
		},
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	// 1) Create bill row via activity
	var bill Bill
	if err := workflow.ExecuteActivity(ctx,
		CreateBillRowActivity,
		CreateBillRowInput{BillID: params.BillID, Currency: params.Currency},
	).Get(ctx, &bill); err != nil {
		return nil, err
	}

	state := &BillResult{
		BillID:      params.BillID,
		Currency:    params.Currency,
		TotalMinor:  0,
		LineItemIDs: make([]string, 0),
	}

	addCh := workflow.GetSignalChannel(ctx, signalAddLineItem)
	closeCh := workflow.GetSignalChannel(ctx, signalCloseBill)

	for {
		shouldClose := false
		sel := workflow.NewSelector(ctx)

		// 2) Add line item signal -> activity insert + accrue
		sel.AddReceive(addCh, func(c workflow.ReceiveChannel, more bool) {
			var sig AddLineItemSignal
			c.Receive(ctx, &sig)

			// ignore mismatched currency
			if sig.Currency != state.Currency {
				return
			}

			var li LineItem
			err := workflow.ExecuteActivity(ctx,
				AddLineItemActivity,
				AddLineItemInput{
					LineItemID:  sig.LineItemID,
					BillID:      state.BillID,
					Description: sig.Description,
					AmountMinor: sig.AmountMinor,
					Currency:    sig.Currency,
				},
			).Get(ctx, &li)
			if err != nil {
				// letting the workflow error here is reasonable for take-home;
				// you could also log and continue depending on your semantics.
				panic(err)
			}

			state.TotalMinor += li.AmountMinor
			state.LineItemIDs = append(state.LineItemIDs, li.ID)
		})

		// 3) Close signal -> break loop
		sel.AddReceive(closeCh, func(c workflow.ReceiveChannel, more bool) {
			var sig CloseBillSignal
			c.Receive(ctx, &sig)
			shouldClose = true
		})

		sel.Select(ctx)
		if shouldClose {
			break
		}
	}

	// 4) Close bill row via activity
	var closed Bill
	if err := workflow.ExecuteActivity(ctx,
		CloseBillActivity,
		CloseBillInput{BillID: state.BillID, TotalMinor: state.TotalMinor},
	).Get(ctx, &closed); err != nil {
		return nil, err
	}

	return state, nil
}
